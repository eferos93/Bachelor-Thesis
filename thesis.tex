%% Le lingue utilizzate, che verranno passate come opzioni al pacchetto babel. Come sempre, l'ultima indicata sarà quella primaria.
%% Se si utilizzano una o più lingue diverse da "italian" o "english", leggere le istruzioni in fondo.
\def\thudbabelopt{english}
%% Valori ammessi per target: bach (tesi triennale), mst (tesi magistrale), phd (tesi di dottorato).
\documentclass[target=bach]{thud}[2014/03/11]
\usepackage{adjustbox}
\usepackage{tabularx}
\usepackage{float}
\usepackage{hyperref}
\usepackage{graphicx}
%\usepackage{bera}% optional: just to have a nice mono-spaced font
\usepackage{listings}
\usepackage{xcolor}
%\usepackage{natbib}
\usepackage{tocbibind}
\usepackage{mathtools}
%\usepackage{cite}

\definecolor{lightgray}{rgb}{0.95, 0.95, 0.95}
\definecolor{darkgray}{rgb}{0.4, 0.4, 0.4}
%\definecolor{purple}{rgb}{0.65, 0.12, 0.82}
\definecolor{editorGray}{rgb}{0.95, 0.95, 0.95}
\definecolor{editorOcher}{rgb}{1, 0.5, 0} % #FF7F00 -> rgb(239, 169, 0)
\definecolor{editorGreen}{rgb}{0, 0.5, 0} % #007C00 -> rgb(0, 124, 0)
\definecolor{orange}{rgb}{1,0.45,0.13}		
\definecolor{olive}{rgb}{0.17,0.59,0.20}
\definecolor{brown}{rgb}{0.69,0.31,0.31}
\definecolor{purple}{rgb}{0.38,0.18,0.81}
\definecolor{lightblue}{rgb}{0.1,0.57,0.7}
\definecolor{lightred}{rgb}{1,0.4,0.5}

\lstdefinelanguage{JavaScript}{
  morekeywords={typeof, new, true, false, catch, function, return, null, catch, switch, var, if, in, while, do, else, case, break},
  morecomment=[s]{/*}{*/},
  morecomment=[l]//,
  frame=lines,
  morestring=[b]",
  morestring=[b]'
}

\colorlet{punct}{red!60!black}
\definecolor{background}{HTML}{EEEEEE}
\definecolor{delim}{RGB}{20,105,176}
\colorlet{numb}{magenta!60!black}
\definecolor{color:keyword}{rgb}{0.53,0.05,0.05}
\definecolor{color:comment}{rgb}{0.25,0.37,0.75}
\definecolor{color:string}{rgb}{0.87,0.0,0.0}

\lstdefinelanguage{Jolie}{
 morekeywords={csets,type,raw,any,undefined,void,default,if,for,while,spawn,foreach,else,define,main,include,constants,inputPort,outputPort,interface,execution,cset,nullProcess,RequestResponse,OneWay,throw,throws,install,scope,embedded,init,synchronized,global,is_defined,is_int,is_bool,is_long,is_string,bool,long,int,string,double,undef,with,Location,Protocol,Interfaces,Aggregates,Redirects,linkIn,linkOut},
 sensitive=true,
 morecomment=[l]{//},
 morecomment=[s]{/*}{*/},
 morestring=[b]",
 otherkeywords={;,|,@}
}

\lstset{
 language=Jolie,
 mathescape=true,
 resetmargins=true,
 numberstyle=\footnotesize,
 numbers=left,
 numbersep=5pt,
 numberblanklines=true,
 basicstyle=\ttfamily\small,
 tabsize=2,
 frame=lines,
 commentstyle=\ttfamily\color{color:comment},
 stringstyle=\color{color:string},
 captionpos=b,
 keywordstyle=\bfseries\color{color:keyword},
 showstringspaces=false,
 belowcaptionskip=10mm,
 breaklines=false,
 columns=fullflexible,
 linewidth= 0.8\linewidth
}


\colorlet{punct}{red!60!black}
\definecolor{keyword}{RGB}{48,0,211}
\colorlet{numb}{magenta!60!black}

\newcommand{\kwd}[1]{{\color{keyword}\textbf{#1}}}
\newcommand{\hid}[1]{{\color{gray}#1}}

\lstdefinelanguage{json}{
    basicstyle=\ttfamily\small,
    commentstyle=\color{color:comment}, % style of comment
    stringstyle=\color{color:string}, % style of strings
    numbers=left,
    numberstyle=\scriptsize,
    stepnumber=1,
    numbersep=8pt,
    showstringspaces=false,
    frame=lines,
    string=[s]{"}{"},
    comment=[l]{:\ "},
    morecomment=[l]{:"},
    literate=
        *{0}{{{\color{numb}0}}}{1}
         {1}{{{\color{numb}1}}}{1}
         {2}{{{\color{numb}2}}}{1}
         {3}{{{\color{numb}3}}}{1}
         {4}{{{\color{numb}4}}}{1}
         {5}{{{\color{numb}5}}}{1}
         {6}{{{\color{numb}6}}}{1}
         {7}{{{\color{numb}7}}}{1}
         {8}{{{\color{numb}8}}}{1}
         {9}{{{\color{numb}9}}}{1}
         {\$}{{{\color{numb}{\$}}}}{1}
}
%\lstdefinelanguage{json}{
%    basicstyle=\normalfont\ttfamily,
%    numbers=left,
%    numberstyle=\scriptsize,
%    stepnumber=1,
%    numbersep=8pt,
%    showstringspaces=false,
%    breaklines=true,
%    frame=lines,
%    backgroundcolor=\color{background},
%    literate=
%     *{0}{{{\color{numb}0}}}{1}
%      {1}{{{\color{numb}1}}}{1}
%      {2}{{{\color{numb}2}}}{1}
%      {3}{{{\color{numb}3}}}{1}
%      {4}{{{\color{numb}4}}}{1}
%      {5}{{{\color{numb}5}}}{1}
%      {6}{{{\color{numb}6}}}{1}
%      {7}{{{\color{numb}7}}}{1}
%      {8}{{{\color{numb}8}}}{1}
%      {9}{{{\color{numb}9}}}{1}
%      {:}{{{\color{punct}{:}}}}{1}
%      {,}{{{\color{punct}{,}}}}{1}
%      {\{}{{{\color{delim}{\{}}}}{1}
%      {\}}{{{\color{delim}{\}}}}}{1}
%      {[}{{{\color{delim}{[}}}}{1}
%      {]}{{{\color{delim}{]}}}}{1},
%}


%% --- Informazioni sulla tesi ---
%% Per tutti i tipi di tesi
\title{Design and implementation of a Language Server for the Jolie programming language}
\author{Eros Fabrici}
\course{Tecnologie Web e Multimediali}
\supervisor{Prof.\ Marino Miculan}
%% Altri campi disponibili: \reviewer, \tutor, \chair, \date (anno accademico, calcolato in automatico).
%% Con \supervisor, \cosupervisor, \reviewer e \tutor si possono indicare più nomi separati da \and.
%% Per le sole tesi di dottorato
%%\phdnumber{313}
%%\cycle{XXVIII}
%%\contacts{Via della Sintassi Astratta, 0/1\\65536 Gigatera --- Italia\\+39 0123 456789\\\texttt{http://www.example.com}\\\texttt{inbox@example.com}}
%%\rights{Tutti i diritti riservati a me stesso e basta.}
%% Campi obbligatori: \title, \author e \course.

%% --- Pacchetti consigliati ---
%% hyperref: Regola le impostazioni della creazione del PDF... più tante altre cose.
%% tocbibind: Inserisce nell'indice anche la lista delle figure, la bibliografia, ecc.

%% --- Stili di pagina disponibili (comando \pagestyle) ---
%% sfbig (predefinito): Apertura delle parti e dei capitoli col numero grande; titoli delle parti e dei capitoli e intestazioni di pagina in sans serif.
%% big: Come "sfbig", solo serif.
%% plain: Apertura delle parti e dei capitoli tradizionali di LaTeX; intestazioni di pagina come "big".

\begin{document}

%% Il frontespizio prima di tutto!
\maketitle

%% Dedica (opzionale)
\begin{dedication}Al mio cane,\par per avermi ascoltato mentre ripassavo le lezioni.\end{dedication}

%% Ringraziamenti (opzionali)
\acknowledgements
Sed vel lorem a arcu faucibus aliquet eu semper tortor. Aliquam dolor lacus, semper vitae ligula sed, blandit iaculis leo. Nam pharetra lobortis leo nec auctor. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Fusce ac risus pulvinar, congue eros non, interdum metus. Mauris tincidunt neque et aliquam imperdiet. Aenean ac tellus id nibh pellentesque pulvinar ut eu lacus. Proin tempor facilisis tortor, et hendrerit purus commodo laoreet. Quisque sed augue id ligula consectetur adipiscing. Vestibulum libero metus, lacinia ac vestibulum eu, varius non arcu. Nam et gravida velit.

%% Sommario (opzionale)
\abstract
Nunc ac dignissim ipsum, quis pulvinar elit. Mauris congue nec leo ornare lobortis. Nulla hendrerit pretium diam nec lobortis. Nullam aliquam laoreet nisl, sit amet facilisis lectus accumsan ut. Duis et elit hendrerit metus venenatis condimentum. Integer id eros molestie, interdum leo sit amet, aliquet metus. Integer fermentum tristique magna, vel luctus neque rhoncus vel. Ut hendrerit et quam et semper. Mauris egestas, odio sed aliquet luctus, magna orci euismod odio, vitae lacinia tellus tellus non lectus. Aliquam urna neque, porta et mattis aliquam, congue sit amet lorem. In ultrices augue sit amet ante vehicula, vitae rhoncus turpis auctor. Donec porta scelerisque eros, at mollis enim imperdiet ut. 

%% Indice
\tableofcontents

%% Lista delle tabelle (se presenti)
%\listoftables

%% Lista delle figure (se presenti)
%\listoffigures

%% Corpo principale del documento
\mainmatter

%% Parte
%% La suddivisione in parti è opzionale; talvolta sono sufficienti i capitoli.

%% Capitolo
\chapter{Introduction}
%%Problem: implementing advance IDE functionalities for the Jolie language to be added in Microsoft Vs-code and similar

\chapter{Jolie and the Language Server Protocol}
\label{sec:JolieLSP}
\section{Jolie: Java Orchestration Language Interpreter Engine}
Service-Oriented Computing (SOC) is a design methodology that focuses on the
composition of autonomous entities in a system, called services. SOC abstracts
from the implementation details of services by imposing a standard communication mechanism between the entities in an SOA (Service-Oriented Architecture)\cite{Jol}. From the perspective the aforementioned methodologies, it is possible to identify a separation between \textit{behavioral} and \textit{architectural} composition of services. The first denotes a series of interactions to be performed in order to reach a goal, while the second deals with the topological structure of a SOA, managing its execution and integration. The lack of an homogeneous solution between the \textit{behavioral} and the \textit{architectural} composition of services require ad-hoc interventions in order to integrate them, which will make the entire architecture less modular and difficult to maintain.\\\textbf{Jolie} was created with the intention to fill the aforementioned gap. This language permits to define services, their behavioral composition, supporting different communication technologies, and their organization inside a SOA.\\A Jolie program defines a service, which is composed by two parts: the \textit{behavior} and the \textit{deployment}. The first defines the functionalities of the service, including primitives like communication and computation constructs. These does not define \textit{how} the communication is supported, they abstractly refer to \textit{communication ports} which are assumed to be correctly defined in the deployment part. For example, a behavioral primitive may express the action "ask the bank to show the actual balance", without knowing how to reach the "bank" service and which communication protocol it uses. These last two are handled by the deployment, which permits to define the \textit{location} and the \textit{protocol} of the bank service. Furthermore, the deployment permits the usage of architectural primitives for defining the architecture of a SOA. The syntax of a Jolie program is defined as the following:
\[Program \quad \Coloneqq \quad	D \quad \textcolor{color:keyword}{main}\,\{\, B\, \}\]
where D is the Deployment and B is the Behavior. The \textcolor{color:keyword}{main} procedure is the execution entry point. 
\subsection{Behavior}
Jolie syntax is a combination of the message passing and the imperative programming styles. 
Following a selection of the Jolie behavioral syntax:\\
{\setstretch{0.4}
\begin{align*}
	B \quad \Coloneqq&\, \eta \quad (input)\\
	|& \, \bar{\eta} \quad (output)\\
	|& \, \textcolor{color:keyword}{if}(e) \> B_1 \> \big[else \> B_2\big] \quad (condition)\\
	|& \, \textcolor{color:keyword}{while}(e) \> B \quad (while)\\
	|& \, \textcolor{color:keyword}{for}(init,\,cond,\,incr)\> B \quad (forLoop)\\
	|& \, \textcolor{color:keyword}{for}(x \, in \, y)\> B \quad (arrayIteration)\\
	|& \, B_1 \, ; \, B_2 \quad (sequential)\\
	|& \, B_1 \, | \, B_2 \quad (parallel)\\
	|& \, \{\, B \,\} \quad (block)\\
	|& \, x\,=\,e \quad (assign)\\
	|& \, a\,->\,e \quad (alias)\\
	|& \, x \, << \, y \quad (deepCopy)\\
	|& \, \big[\,\eta_1\,\big]\>\{\,B_1\,\}\,...\, \big[\,\eta_n\,\big]\>\{\,B_n\,\} \quad (inputChoice)\\
	|& \, \textcolor{color:keyword}{scope}(s) \> \{\,B\,\} \quad (scope)\\
	|& \, \textcolor{color:keyword}{install}(\,h_1\> => \>B_1,...,\,h_n\> => \> B_n) \quad (install)\\
	|& \, \textcolor{color:keyword}{throw}(f[,\,x]) \quad (throw)
\end{align*}
%	|& \, \textcolor{color:keyword}{cH} \quad (cH)\\
where
\begin{align*}
	\eta \quad \Coloneqq&\, opName(x) \quad (OneWay)\\
	|& \, opName(x)(e)\>\{\,B\,\} \quad (RequestResponse)
\end{align*}\\
and
\begin{align*}
	\bar{\eta} \quad \Coloneqq&\, opName\textcolor{color:keyword}{@}OP(e) \quad (notification)\\
	|&\, opName\textcolor{color:keyword}{@}OP(e)(x) \quad (SolcitResponse)
\end{align*}
}
\subsubsection{Communications}
Communications are implemented through \textit{Rules} \textit{(input)}, \textit{(output)} and \textit{(inputChoice)}. Input $\boldsymbol\eta$ can be either a \textit{OneWay} or a \textit{RequestResponse}. The first receives a message for the operation \textit{opName} and saves its content in variable \verb|x|, while the second receives a message for operation \textit{opName} in variable \verb|x|, executes behavior \textit{B} and sends the value of the evaluation of the expression \textit{e} to the invoker. \textit{(notification)} and \textit{(SolcitResponse)}  implement the output towards the input . The first sends a message with the evaluation of \textit{e}, the second does the same thing and waits for the response from the invoked service which is stored in the var \verb|x|. \textit{OP} denotes the \textbf{output port name} that references an \textcolor{color:keyword}{outputPort}. The latter is specified in the deployment definition and it contains all the necessary information in order to contact the target service. Lastly, the \textit{(inputChoice)} supports the receiving of a message for any of the inputs. When a message for the input $\eta_i$ is received, all the remaining branches are deactivated and $\eta_i$ is executed. Afterwards, $B_i$ is executed. The interpreter enforces that $\eta_i \neq \eta_j,\,\forall i,j \in [1,n] \, | \, i \neq j$, which means that there cannot be two inputs with the same operation.\\\textbf{Statement compositions}, such that \textit{(condition)}, \textit{(while)}, \textit{(forLoop)}, \textit{(arrayIteration)} and \textit{(block)}, resembles the ones used in classic imperative styles. Rule \textit{sequential} sequentially compose the two behaviors: when $B_1$ is terminated, $B_2$ can start its execution (remark: the separator \textit{;} is now optional). On the contrary, \textit{(parallel)} permits the parallel execution of the two behaviors.\\\textbf{Assignment and aliasing}: \textit{(assign)} evaluates the expression \textit{e} and assigns its value to the variable \verb|x|. \textit{(alias)} permits to define a variable $a$ that points to $x$ variable path.\\\textbf{Handling data} Jolie is dynamically-typed meaning that there is no necessity of type declarations and that the type of a variable value is checked at runtime. The language handles the following basic data types:
\begin{itemize}
	\item \verb|bool|: booleans;
	\item \verb|int|: integers;	
	\item \verb|long|: long integers (with \verb|l| or \verb|L| suffix);
	\item \verb|double|: double-precision float;
	\item \verb|string|: strings;
	\item \verb|raw|: byte arrays (supported for data-passing purposes);
	\item \verb|void|: the empty type.
\end{itemize}
Jolie supports basic arithmetic and logic operators like in Java and also pre-/post-increment and pre-/post-decrement operators. Furthermore, it is possible to cast variables to other types with the following casting functions: \verb|bool()|, \verb|int()|, \verb|long()|, \verb|double()| and \verb|string()|. For instance:
\begin{lstlisting}[language=jolie]
	d = "1.5"
	n = double( d ) // n = 1.5
	n = int( n ) // n = 1
\end{lstlisting}
A variable type can be checked at run-time with the \textcolor{color:keyword}{instanceof} operator, whose syntax is:
\[expression \>\> \textcolor{color:keyword}{instanceof} \>\> (native\_type\,|\,custom\_type)\]
Variables are undefined until they are assigned a value. Until then, their state is set to \textcolor{color:keyword}{undefined} (equivalent to \verb|NULL|, \verb|null| or \verb|nil| in other languages). The predicate \textcolor{color:keyword}{is\_defined} is used for checking is a variable is defined or not. Following the syntax:
\[ \textcolor{color:keyword}{is\_defined} (\, variable\_name \,)\]
An example:
\begin{lstlisting}[language=jolie]
	x = 2
	if ( is_defined( x ) ) {
		println@Console( "Variable x is defined" )
	}
\end{lstlisting}
Arrays in Jolie are handled dynamically and can be accessed using the \verb|[]| operator. To be more precise, in Jolie \textbf{every} variable is a dynamic array. So for example this assignment
\begin{lstlisting}[language=jolie]
	x = 7
\end{lstlisting}
is equivalent to the following
\begin{lstlisting}[language=jolie]
	x[0] = 7
\end{lstlisting}
thus managing complex data is easier. To compute the size of an array Jolie provides the size operator \verb|#|. Together with this operator, the aforementioned \textit{forLoop} can be used to traverse an array. Alternatively, \textit{(arrayIteration)} has the same purpose. The example below shows the usage of the mentioned constructs.
\begin{lstlisting}[language=jolie]
	x[0] = 1
	x[1] = 2
	x[2] = 3
	println@Console( #x )() // prints 3
	
	for( i = 0, i < #x, i++) {
		println@Console( x[i] )()	
	}
	//which is equivalent to
	for( el in x ) {
		println@Console( el )()	
	}
\end{lstlisting}
\subsubsection{Data Structures}
Data structures in Jolie are tree-like, similarly to XML or JSON data trees. The operator \verb|.| is used to traverse a data structure. Following an example.
\begin{lstlisting}[language=jolie]
	doctor.name = "Marco"
	doctor.surname = "Rossi"
	doctor.age = 45
	doctor.specialization[0] = "Cardiology"
	doctor.specialization[1] = "General Surgery"
\end{lstlisting}
The above data tree is catheterized by \verb|doctor| as root with \verb|void| type and by three children: \verb|name|, \verb|surname| and \verb|specialization| which respectively have the types \verb|string|, \verb|string|, \verb|int| and \verb|string|. The \textcolor{color:keyword}{undef} operator is used to erase an entire structure. Syntax:
\[\textcolor{color:keyword}{undef}(\,variable\_name\,) \]
The \textit{(deepCopy)} operator copies the entire structure of a tree $y$ into a tree $x$. Jolie at run-time explores the tree $y$ node-wise and for all initialized sub-nodes in $y$, it assigns the value of each of them to the corresponding sub-node rooted in $x$. This means that if $x$ already had sub-nodes initialized that match to some ones rooted in $y$, $x \, << \, y$ will overwrite them, leaving all the others initialized nodes of $x$ unaffected. This operator can be used also as syntax sugar for creating a data structure. Basing on the previous example of the doctor data structure, in can be re-written as in the following example.
\begin{lstlisting}[language=jolie]
	doctor << {
		name = "Marco"
		surname = "Rossi"
		birthDate << {
			day = 25
			month = 5
			year = 1971
		}
		specialization[0] = "Cardiology"
		specialization[1] = "General Surgery"
		email = "marco.rossi@gmail.com"
	}
\end{lstlisting}
\subsubsection{Fault handling}
Jolie has constructs to handle faults. The primitives meant for this purpose are: \textcolor{color:keyword}{scope}, \textcolor{color:keyword}{install} and \textcolor{color:keyword}{throw}. For more details see \cite{Jol}.
\subsection{Deployment}
The deployment is the part of a Jolie program in which all the necessary information for establishing communication channels between services are established. The basic primitives are \textit{input ports} and \textit{output ports} which are based on \textit{data types} and \textit{interfaces}. A deployment $D$ is simply a list of deployment instructions among which we can have input and output ports, type definitions, and interfaces \cite{Jol}:
%{\setstretch{0.4}
\begin{align*}
	D \>\> \Coloneqq& \>\> IP \quad (inputPort)\\
	|& \> OP \quad (outputPort)\\
	|& \> T_{def} \quad (typeDefinition)\\
	|& \> I \quad (interface)\\
	|& \> \textcolor{color:keyword}{execution}\{\, M \,\}\\
	|& \> E
\end{align*}
%}
\subsubsection{Communication ports}
Communication ports are primitives that define \textit{how} communications with other services are handled. There are two kind of ports. $(inputPort)$ that exposes input operations to other services. Alternatively, $(outputPort)$ permits the invocation of other services' operations.\\The syntax for input and output port is the following.
%{\setstretch{0.4}
\begin{align*}
	IP \quad \Coloneqq \> &\textcolor{color:keyword}{inputPort}: \, id \> \{\\
	&\textcolor{color:keyword}{location}: \, URI\\
	&\textcolor{color:keyword}{protocol}: \, p\\
	&\textcolor{color:keyword}{interfaces}: \, I_1,\,I_2,...,\,I_n\\
	& \big[ \textcolor{color:keyword}{aggregates}: OPid_1,...,OPid_n\big]\\
	&\}
\end{align*}
\begin{align*}
	OP \quad \Coloneqq \> &\textcolor{color:keyword}{outputPort}: \, id \> \{\\
	&\textcolor{color:keyword}{location}: \, URI\\
	&\textcolor{color:keyword}{protocol}: \, p\\
	&\textcolor{color:keyword}{interfaces}: \, I_1,\,I_2,...,\,I_n\\
	&\}
\end{align*}
%}
These ports are based on three concepts of $location$, $protocol$ and $interface$. The former two define the concrete binding between the program and other services. In particular the $location$ must specify the communication medium. The mediums supported are: \textit{local} (jolie in-memory communication), \textit{socket}, \textit{btl2cap} (Bluetooth L2CAP), \textit{rmi} (Java RMI) and \textit{localsocket} (Unix local sockets). The $protocol$ indicates the data format. Jolie supports the following protocols: \textit{HTTP}, \textit{HTTPS}, \textit{JSON-RPC}, \textit{XML-RPC}, \textit{SOAP}, \textit{SODEP} (created and developed for Jolie), \textit{SODEPS} and \textit{RMI}. More details about the mediums and protocols can be found at \cite{JolieDoc}. The $interface$ defines a bind between the deployment and the behavior: more specifically it defines type information that is expected to be satisfied by the behavior that uses the ports.
\subsubsection{Data types and interfaces} 
Interfaces are a collection of operation types. The latter defines the type of the data to be communicated over each specified operation. Following the data type syntax.
\[ 
	T_{def} \>\> \Coloneqq \>\> \textcolor{color:keyword}{type} \> id \> T
\]

\[
	T \>\> \Coloneqq \>\> : \> BT \> \big[\{\> id_1 \, R_1 \, T_1 \> ... \> id_n \, R_n \, T_n\> \}\big]\, 	| \, \textcolor{color:keyword}{undefined}
\]

\[
	R \>\> \Coloneqq \>\> [min, \, max] \> | \> *
\]
\[
	BT \>\> \Coloneqq \>\> \textcolor{color:keyword}{int}\,|\,\textcolor{color:keyword}{string}\,|\,\textcolor{color:keyword}{void}\,|\,\textcolor{color:keyword}{bool}\,|\,\textcolor{color:keyword}{long} \,|\, \textcolor{color:keyword}{double} \,|\, \textcolor{color:keyword}{raw} \,|\, \textcolor{color:keyword}{double}
\]
A data type describes the structure of a data tree, the type of its nodes and the cardinality of each node, namely the number of admitted occurrences of a node. Basing on the \verb|doctor| data tree, I give its type definition.
\begin{lstlisting}[language=jolie]
	type Doctor: void {
		name: string
		surname: string
		age : Date
		specialization*: string
		email[0,1]: string
	}
	
	type Date: void {
		day: int
		month: int
		year: int
	}
\end{lstlisting}
Doctor's root has type \textcolor{color:keyword}{void}, thus it must not contain any value. Whereas its nodes, except for \verb|email|, must contain values of the specified type. \verb|email| is an optional node, as its cardinality suggests, hence it is not mandatory to insert it in the data tree. The cardinality, if omitted, is set as [1,1] (which can be read "from one to one occurrences"). The $*$ defines an unlimited number of occurrences, more in detail, it is a syntax sugar for [1,*] ("from one to unlimited occurrences"). The cardinality [0,1] can be written also with the shortcut \verb|?|. Note that since Jolie 1.8.0 release, if the type of the root is \textcolor{color:keyword}{void}, there is no necessity to express it . Therefore the above defined type can be written as it follows.
\begin{lstlisting}[language=jolie]
	type Doctor {
		name: string
		surname: string
		age : Date
		specialization*: string
		email?: string
	}
	
	type Date {
		day: int
		month: int
		year: int
	}
\end{lstlisting}
More generally, a type $T$, can be either a basic type with (optionally) a list of named sub-nodes $BT$, or \textcolor{color:keyword}{undefined}, which makes the type accepting any sub-tree. Each sub-type comes with its $id$, its cardinality (or range) $R$, which can be an interval from $min$ (integer greater or equal than zero) to $max$ (integer greater or equal than $min$ or $*$) and, finally, its type $T$.\\The interface syntax is defined as it follows.
\[I \>\> \Coloneqq \>\> \textcolor{color:keyword}{interface} \> id \> \{ \> \big[\,\textcolor{color:keyword}{OneWay}:\,OW_1,...,\,OW_n\, \big]\> \big[\textcolor{color:keyword}{RequestResponse}:\, \big[\, RR_1,...,\,RR_n \, \big] \> \} \]
\[OW \>\> \Coloneqq \>\> id(\,OT\,) \]
\[RR \>\> \Coloneqq \>\> id(\,OT_{req}\,)(\,OT_{res}\,)\]
\[OT \>\> \Coloneqq \>\> BT \, | \, customTypeName \]
An interface $I$ is a list of possible one-way ($OW$) and request-response ($RR$) operation declarations. An $OW$ definition consists of an operation name $id$ and the type $OT$ of its message. Similarly, an $RR$ definition is composed by its name and both the type of the request message $OT_{req}$ and the type of the response message $OT_{res}$. The deployment permits the type checking of the behaviors. Whenever a message is sent or received through a port, its type is checked against the one specified for its operation in the port's interface. If the type of a message received through an input port does not match to the one defined in the interface, a \verb|TypeMismatch| fault is sent to the invoker. The same fault is thrown for an output statement trying to send a message with the wrong type.
\subsubsection{Behavior instances}
A service participates in a session by executing an instance of its behavior \cite{Jol}. A session can be executed \textit{one time}, multiple times in \textit{sequence} or multiple times in \textit{parallel}. For this purpose, Jolie allows to reuse behavioral definition multiple times with the \textit{execution modality} deployment primitive before shown \textcolor{color:keyword}{execution}\{$M$\} where $M$ syntax is defined as it follows:
\[ M \>\> \Coloneqq \>\> \textcolor{color:keyword}{single} \> | \> \textcolor{color:keyword}{sequential} \> | \> \textcolor{color:keyword}{concurrent}\]
\textcolor{color:keyword}{single} allows the execution of the behavior one time. \textcolor{color:keyword}{sequential} permits the execution of the behavior multiple times, more precisely it causes the program to be available again after the current instance is terminated. Finally, \textcolor{color:keyword}{concurrent} causes the program behavior to be instantiated and executed whenever its first input statement can receive a message \cite{Jol}. In the latter two cases, the behavioral definition must be an input statement or an input choice. The state of a single behavior instance is not shared between the other instances, meaning that all the variables used are local to the behavior instance. Despite this, Jolie provides global variable support through the keyword \textcolor{color:keyword}{global}, which is used as a prefix on variable names. Following an example:
\begin{lstlisting}[language=jolie]
	global.x = 5 //global variable x
	y = 3 // local variable y
\end{lstlisting}
This permits sharing data between different behavior instances, which access can be restricted through \textcolor{color:keyword}{synchronized} blocks
\[B \>\> \Coloneqq \>\>...\>|\>\textcolor{color:keyword}{synchronized} \> (\,token\,)\>\{\,B\,\} \]
that allows only one process at a time to enter any \textcolor{color:keyword}{synchronized} with the same $token$.
\subsubsection{Architectural composition}
Architectural composition is a different kind of composition that a deployment definition can obtain abstracting from the specific behavioral definitions of the involved services \cite{Jol}. Architectural composition can be divided in two categories:
\begin{itemize}
	\item \textsc{the execution context}: a service may execute other services in the same execution context. The linguistic primitive which allows the programming of execution contexts is the embedding \cite{JolieDoc} which can be distinguished between \textit{static} and \textit{dynamic}. In this thesis only the static embedding is presented, for more details and the dynamic embedding see \cite{Jol,JolieDoc};
	\item \textsc{the communication topology}: it permits the programming of the connections between services in a micro-service architecture \cite{JolieDoc}. The primitive presented is the \textit{aggregation}, while \textit{redirection}, \textit{couriers} and \textit{collection} can be studied at \cite{Jol,JolieDoc}.
\end{itemize}
\textbf{Static embedding} is a mechanism for executing multiple services in the same virtual machine. A service, called \textit{embedder}, can embed another service, called \textit{embedded}
service, by targeting it with the \textcolor{color:keyword}{embedded} primitive \cite{Jol}. 

\[ E \>\> \Coloneqq \>\> \textcolor{color:keyword}{embedded}\,\{\, E_{type}:\>path\,\big[\,\textcolor{color:keyword}{in} \> OP \, \big] \, \} \]
\[ E_{type} \>\> \Coloneqq \>\> \textcolor{color:keyword}{Jolie} \> | \> \textcolor{color:keyword}{Java} \> | \> \textcolor{color:keyword}{JavaScript} \]
$E_{type}$ specifies the technology of the service to embed, $path$ is a URL pointing to the service definition to embed. Jolie currently supports the three technologies mentioned in the syntax definition, making embedding a \textit{cross-technology} mechanism. An output port $OP$ may be optionally specified. In this case, as soon as the service is loaded, the output port $OP$ is bound to the "local" communication input port of the embedded service \cite{Jol}. For the specific case of embedding a Jolie service into another, the communication medium local must be explicitly indicated in the input port of the embedded service, with no necessity of specifying the protocol, as local medium use an in-memory communication. In an hierarchical perspective, the \textit{embedder} is the parent service of the embedded ones. As a consequence, whenever a service is terminated, all his embedded services are recursively terminated. The hierarchy is also useful for performance: in-memory communications are faster as the services are running inside the same virtual machine. Following a simple example of how embedding with Jolie works.
\begin{lstlisting}[language=jolie]
	//service that computes the length of a string
	interface lengthInterface {
		RequestResponse: length( string )( int )
	}
	inputPort LengthService {
		location: "local"
		interface: lengthInterface	
	}
	main 
	{
		length( request )( response ) {
			response = #request
		}		
	}
\end{lstlisting}

\begin{lstlisting}[language=jolie]
	//embedder service
	include "console.iol"
	
	interface lengthInterface {
		RequestResponse: length( string )( int )
	}
	
	outputPort LengthService {
		interfaces: lengthInterface
	}
	
	embedded {
		Jolie: "length_service.ol" in LengthService
	}
	
	include "console.iol"
	main {
		string = "Hello World!"
		length@LengthService( string )( result )
		println@Console( result )()
	}
\end{lstlisting}
\textbf{Aggregation} is a generalization of network proxies that allows a service to expose
operations without implementing them in its behavior, but instead delegating them to other services \cite{Jol}. The syntax, as shown previously, $\textcolor{color:keyword}{aggregates}: \> OPid_1,...,\,OPid_n$ extends that for input ports, where $OPid$ is the $id$ of an output port. The interfaces of the aggregated output ports must not share any operation name. Whenever an input port $IP$ receives a message for operation $opName$, there are three possible cases:
\begin{itemize}
	\item $opName$ is an operation declared in one of the interfaces of $IP$. In this case, the message in treated normally as previously described.
	\item $opName$ is declared in the interface of an output port $OP$ aggregated by $IP$, hence the message is forwarded to $OP$ as an output message of the \textit{aggregator}.
	\item Neither in the interface of the aggregated output ports nor in the $IP$'s interfaces $opName$ is declared. Consequently, the message is rejected and an \verb|IOException| fault is sent to the invoker.  
\end{itemize}
Aggregation, therefore, is a mechanism that merges of the aggregated output ports and make them accessible through a single input port. From the invoker perspective, all the aggregated services are seen as a single one. Following an example of aggregation and embedding.
\begin{lstlisting}[language=jolie]
	outputPort A {
	 	location: "socket://someurlA.com:80/"
		protocol: soap
		interfaces: InterfaceA
	}
	
	outputPort B {
		location: "socket://someurlB.com:80/"
		protocol: jsonrpc
		interfaces: InterfaceB
	}
	
	embedded { Java: "example.serviceB" in B }
	
	inputPort M { 
		location: "socket://urlM.com:8000/"
		protocol: sodep
		aggregates: A, B
	}
\end{lstlisting}
Observe that service B is actually a Java service (for details regarding Java services, see reference \cite{JolieDoc}), therefore it must be embedded in a output port in order to be able to forward messages to it.

\section{Language Server Protocol}
Implementing advanced features like auto-complete, hover information, diagnostics and go to definition for a programming language can take a significant effort. Typically, this work has to be repeated for every editor or IDE as each of them might offer different APIs for implementing the same feature. A Language Server is a software program that is intended to provide the aforementioned language-specific features and communicate with a development tool through a communication protocol.\\The Language Server Protocol was developed by Microsoft to standardize the protocol for how such servers and IDEs communicate. Therefore, on one hand, the single Language Server can be reused for each development tool that implements the aforementioned protocol, on the other hand, the editor can support multiple languages with minimal effort.
\subsection{How LSP works}
A Language Server runs as a separate process and the development tool communicate with the server using JSON-RPC, a remote procedure protocol which uses JSON syntax as data-format. An LSP message is composed by two parts: the \textit{header} part and the \textit{content} part. The first part is composed by 
\begin{table}[H]
	\caption{LSP headers}
	\begin{tabularx}{\textwidth}{c|c|X}
		\hline
		\textbf{Header Field Name} & \textbf{Value Type} & \textbf{Description}\\
		\hline\hline
		Content-Length & number & The length of the content part in bytes. This header is required.\\\hline
		Content-Type & string & The mime type of the content part. Defaults to application/vscode-jsonrpc; charset=utf-8\\\hline
	\end{tabularx}
\end{table}
The header part is encoded using the 'ascii' encoding. This includes the '\textbackslash r\textbackslash n' separating the header and content part.\\The content part contains the actual content of the message using JSON-RPC to describe requests, responses and notifications, the latter also called one-way messages. Following an example:
\begin{lstlisting}[language=json]
Content-Length: ...\r\n
\r\n
{
	"jsonrpc": "2.0",
	"id": 1,
	"method": "textDocument/didClose",
	"params": {
		...
	}
}
\end{lstlisting}
The Language Server is started by the development tool when certain conditions occur (e.g. when it detects the language in question), therefore the server is required to be spawn as a child process of the client, and the communication between the two can be either via \textit{stdio}, \textit{ipc} or \textit{socket}. More precisely, it is needed to add an extension that must include all the necessary configurations (for which language, conditions that must trigger the extension to start, etc.) in the development tool. This extension must be written in TypeScript/JavaScript and must override the method \textit{activate} of the LSP libraries. This method states all the server and client options, namely the server module, the transport kind (and all the information required accordingly to specific kind of transport), the document selector and other options. The extension is invoked when the triggering conditions aforementioned occur.\\
Following a simplified sequence diagram that shows a slice of interaction between a client and a server.

\begin{figure}[H]
	\includegraphics[width=\textwidth]{lsp.png}
\end{figure}

\begin{enumerate}
	\item \textbf{The user opens a file (referred as a \textit{document})}: the tool notifies the server that a document is open ("textDocument/didOpen"), meaning that it is kept in the tool memory. The server will therefore save the language representation of the document in his memory.
	\item \textbf{The user edits the document}: the tool notifies the server about a change made by the user on the document ("textDocument/didChange"). The server updates the language representation of the document.
	\item \textbf{The tool execute the "Completion Request"}: the request ("textDocument/completion") is triggered by the aforementioned changes. The parameter, \textit{completionParams}, is essentially a JSON object with all the necessary information (documentURI, position, triggerKind) that the server needs to compute the response. Note that this call is \textit{asynchronous}: the tool can send other notifications or request while waiting for the completion response, same for the Language Server.
	\item \textbf{The server publishes errors and warnings}: after the change notification, the server computes and notifies the tool with a list of eventual errors and warnings in the code ("textDocument/publishDiagnostics"). The parameters of this notification contains all the necessary information in order to permit the tool flags errors and warnings.
	\item \textbf{The server replies to the "Completion Request"}: the server after computing a list of possible completion items, replies to the completion request made before by the tool. The latter lists the items received in order to let the user decide which suites the best.
	\item \textbf{The user closes the document}: the tool notifies the server when the user closes the document, which cease to exist in the tool memory. The server erases all the information regarding the aforementioned document. 
\end{enumerate}

All the data types illustrated are language agnostic, meaning that can be applied to all the programming languages. This is due to the protocol simplicity: it is more simple to standardize a document URI or a position inside a it, that standardizing an abstract syntax tree and compiler symbol across different programming languages.\\The aforementioned simplicity is shown in the following JSON-RPC objects that refers to the completion request and response:\\
\textbf{Request}:
\begin{lstlisting}[language=json]
{
	"jsonrpc": "2.0",
	"id" : 1,
	"method": "textDocument/completion",
	"params": {
		"textDocument": {
			"uri": "file:///home/user/Desktop/client.ol"
		},
		"position": {
			"line": 3,
			"character": 7
		},
		"context": {
			"triggerKind": 1
		}
	}
}
\end{lstlisting}
\textbf{Response}:
\begin{lstlisting}[language=json]
{
	"jsonrpc": "2.0",
	"id": 1,
	"result": {
	"isIncomplete": false,
		"items": {
			"label": "println@Console",
			"kind": 2,
			"insertText": "println@Console(  )(  )",
			"insertTextFormat": 2
		}
	}
}
\end{lstlisting}

A Language Server in order to work with LSP does not need to implement all the features. LSP provide \textbf{capabilities}. A capability groups a set of language features. The protocol permits the server to notify the tool which capabilities supports, therefore the tool adapts itself in order to send notifications and requests of the capabilities supported.
\chapter{Analysis of the problem}
\label{sec:Analysis}
In this chapter I will identify the requirements, gathered during the analysis of the Language Server Protocol and over a series of meetings with the supervisor.
\section{Language Server Protocol features}
LSP supports six key feature which are:
\begin{enumerate}
	\item \textbf{Code completion}: feature that speeds up the process of coding applications by reducing typos and other common mistakes;
	\item \textbf{Hover information}: feature that shows information, like the type signature, when the user moves the pointer over an element (such as a function definition);
	\item \textbf{Jump to definition}: feature that shows the definition of a selected symbol;
	\item \textbf{Workspace symbols}: displays all the symbols of the workspace, in order to help the user search for elements inside the workspace (such as classes, variables, methods, etc.);
	\item \textbf{Find references}: given a symbol, this features lists all the project wide references;
	\item \textbf{Diagnostics}: the tool flags syntax errors, warnings together with a description.
\end{enumerate}
The protocol supports many other features that are all linked to the above listed. The requirements elicitation phase was based on these main ones.
\section{Functional Requirements}
\label{sec:FR}
Functional requirements are statements of services the system should provide, particularly how it should react to particular inputs \cite{Som11}. From the features analyzed in the previous section, we extracted the following functional requirements, listed in ascending order of importance.
\begin{table}[H]
	\caption{Functional Requirements}
	\begin{tabularx}{\textwidth}{c|X}
		\hline
		\textbf{Functional r. No.} & \textbf{Description}\\
		\hline\hline
		FR 1 & The server must provide information of eventual programming errors and warnings every time a document is opened/modified.\\\hline
		FR 2 & Every time the user starts typing an operation name, the server returns a list of possible completion items that consists of the full operation name and the output port.\\\hline
		FR 3 & Every time the user starts typing a reserved word, the server provides a list of possible completion items.\\\hline
		FR 4 & Every time a document is opened/modified/closed, the server saves/updates/deletes the information in his memory like the text, URI and a data structure containing all the information regarding the Jolie program (an abstract syntax tree of the \textit{behavior} and data regarding the \textit{deployment}).\\\hline
		FR 5 & The server provides the type signature to the client every time the latter sends an hover request.\\\hline
		FR 6 & The server computes and sends the operation definition every time it receives a definition. request\\\hline
		FR 7 & The server provides a list or hierarchy of symbols of a specific document requested by the client.\\\hline
		FR 8 & Information regarding the workspace are sent to the client and updated every time the client requests them (workspace symbols for example).\\\hline
		FR 9 & The server resolves project wide references of a given symbol.\\\hline 
	\end{tabularx}
\end{table}

\section{Non-functional requirements}
\label{sec:NFR}
Non-functional requirements are requirements that are not directly concerned with the specific services delivered by the system to its users. They may relate to emergent system properties such as reliability, response time, and store occupancy. Alternatively, they may define constraints on the system implementation such as the capabilities of I/O devices or the data representations used in interfaces with other systems \cite{Som11}.\\ Regarding the aforementioned non-functional requirements, the response time is critical for the project, as the server should be able to respond to the client as soon as possible. Nonetheless, this kind of calculations (such as code completion) are not computationally heavy.\\Other non-functional requirements, are listed below.
\subsection{Complying with the Language Server Protocol specification}
The Language Server Protocol defines a common language, between a tool and a Language Server. As a consequence, the latter must be able to recognize different requests received from the client and send back proper responses that the client is able to interpret and compute.\\Following an example: the request-response method \verb|initialize|, that provides the server client's capabilities and it expects a response with the server capabilities, has the following type:\\\textbf{Request type}
\begin{lstlisting}[language=javascript]
interface InitializeParams {
	processId: number | null;
	rootPath?: string | null;
	rootUri: DocumentUri | null;
	initializationOptions?: any;
	capabilities: ClientCapabilities;
	trace?: 'off' | 'messages' | 'verbose';
	workspaceFolders?: WorkspaceFolder[] | null;
}
\end{lstlisting}
\textbf{Response type}
\begin{lstlisting}[language=javascript]
interface InitializeResult {
	/**
	 * The capabilities the language server provides.
	 */
	capabilities: ServerCapabilities;
}
\end{lstlisting}
\subsubsection{JSON-RPC 2.0 Protocol}
Regarding the communication protocol, LSP supports a custom version of the JSON-RPC 2.0 protocol, as mentioned in \hyperref[sec:JolieLSP]{Chapter 2}. A message is characterized by an header part, which can contain up to two headers (Content-Length, which is mandatory, and Content-Type) and a content part, with the actual message represented with the JSON-RPC notation.\\Jolie supports JSON-RPC, but it runs over HTTP, therefore Jolie's JSON-RPC will expect HTTP headers before the Content-Length and Content-Type. As a consequence, Jolie's JSON-RPC protocol must be extended in order to make it compatible with LSP messages.
\subsection{Distributed}
The server must be adapted to the LSP, in order to make it works with different tools that uses the protocol concerned. Therefore, it must be \textbf{editor-agnostic} and it should be designed and implemented in order to be deployed both locally and in a different machine with respect to the clients, so it can interact with different tools at the same time. The LSP specifications indicates that when the development tool starts the plug-in, the latter will immediately start  Consequently the best communication channel to use is the socket.
\subsection{Modular}
Not every Language Server can support all features defined by the protocol. LSP therefore provides, the previous mentioned, \textbf{capabilities}, as stated in \hyperref[sec:JolieLSP]{Chapter 2}. A capability groups a set of language features. A development tool and the Language Server announce their supported features using capabilities. For instance, the server announces that it can handle the \verb|textDocument/hover| request, but it might not support the \verb|textDocument/references| request. Similarly, a development tool announces its ability to provide \verb|textDocument/didChange| notification when a document is modified, so that a server can compute textual edits to format the edited document.\\On account of this, the server must be designed in order to easily add new capabilities or improve the existing ones. After implementing a new feature, the programmer just need to modify the server capabilities thus the client can start sending requests regarding the newly activated capability.

\begin{table}[H]
	\caption{Non-Functional Requirements}
	\begin{tabularx}{\textwidth}{c|X}
		\hline
		\textbf{Non-functional r. No.} & \textbf{Description}\\
		\hline\hline
		NFR 1 & The server must support the LSP's JSON-RPC protocol.\\\hline
		NFR 2 & The server must be designed to be modular.\\\hline
		NFR 3 & The server must be able to respond to a client request as soon as possible.\\\hline
		NFR 4 & The server must work both when deployed in a different machine and when deployed in a local machine, with respect of the client location. As a consequence, it has to support the socket channel of communication.\\\hline
		NFR 5 & The server if distributed, must be able to handle more clients sending multiple requests at the same time.\\\hline
	\end{tabularx}
\end{table}

\chapter{System architecture}
The architecture of a system identifies the components that form a system and the relationships between them. Graphical models are the best technique to abstractly represent a system architecture. Software architecture is important because it affects the performance, robustness,
distributability, and maintainability of a system (Bosch, 2000) \cite{Som11}. In order to satisfy the non-functional, in particular NFR 2 and NFR 5 requirements defined in \hyperref[sec:Analysis]{Chapter 3}, the architecture adopted is the Service Oriented Architecture. Instead of a monolithic architecture, SOC is more scalable: the direct communication with the client is handled by a single service which deals with the initialization and the termination of the entire server while it forwards all the other requests and notifications sent by the development tool to the service responsible for treating the specific message (e.g. the message \verb|textDocument/didOpen|, when received by the main service, named \textit{orchestrator}, forwards the message to the textDocument service, namely the service that handles all the textDocument messages).
\section{Architecture}
In this section I present two architectures according to NFR 4. One architecture, represents the system with the Language Server deployed in the same machine as the development tool, while the other describes the architecture of the system when the Language Server is deployed in a different machine than the client.
\begin{figure}[H]
	\caption{Architecture in L.S. and dev. tool in a single machine}
	\includegraphics[width=\textwidth]{local_arch.png}
\end{figure}
\begin{figure}[H]
	\caption{L.S. and dev. tool in different machines}
	\includegraphics[width=\textwidth]{distr_arch.png}
\end{figure}
\begin{figure}[H]
	\centering
	\caption{Legenda}
	\includegraphics[height=10cm]{legenda.png}
\end{figure}

The hexagon represents a \textit{macroservice}, which is an unique execution context for a set of services. A macroservice exhibit only the public available ports of the inner services \cite{JolieDoc}.
\subsection{Services}
Each service presented in the model has a set of operations. The main difference between the two models is that in the distributed model there is one more service deployed in the development tool machine that acts as a forwarder. This is necessary as the client process expects a child process that contains the server. The client then will communicate with this service that forwards all its messages to the real Language Server deployed in a remote machine.
\subsubsection{Main service}
The main service presents two input ports and three output ports. One input port is used to receive the requests and notifications sent by the client, the other is used by an another service, called \textit{utils}, with the purpose to receive all the notifications to be sent to the client through one of the output ports. The remaining two output ports, point to the two main services of the server, \textit{textDocument} and \textit{workspace} and they should be aggregated by the first mentioned input port, therefore every message si automatically forward to the respective service.\\The operations offered by this service are those necessary for initialization and termination of the server. For more details see reference \cite{LSPSpec}. The service must handle at least the following requests and notifications:
\begin{itemize}
	\item \verb|initialize| request which content contains the \textit{client capabilities}. The response consists of the \textit{server capabilities};
	\item \verb|initialized| notification. An empty message acting as an ACK for the \verb|initialize| response;
	\item \verb|shutdown| request. Empty message that expects an empty response;
	\item \verb|exit| notification. After receiving the \verb|shutdown| response, a notification is sent and the server must terminate its execution.	
\end{itemize}
\subsubsection{Text Document service}
The service \textit{textDocument} handles all the text document messages. In order to meet the \hyperref[sec:FR]{functional requirements} the service must serve the following messages:
\begin{itemize}
	\item \verb|textDocument/completion| request. This request is sent with a cursor position and expects a response with a list of completion items that will be presented in the user interface;
	\item \verb|textDocument/didOpen|, \verb|textDocument/didChange|, \verb|textDocumet/didClose| notifications. Messages used for synchronize the document's truth with the language server. The service should forward the message to the service \textit{utils} that will respectively store, update or delete the information regarding the document (URI, text, etc.);
	\item \verb|textDocument/hover| request is sent together with a cursor position thus the service could compute a response with the information of what is located in that document position.
	\item \verb|textDocument/documentSymbol| request requires a flat list or hierarchy of a symbols of a specified document.
	\item \verb|textDocument/definition| request. The client requires the server to resolve the definition location of a given document symbol at a given text document position.
	\item \verb|textDocument/references| request is sent in order to resolve project-wide reference of the symbol denoted by the given text document position.
\end{itemize}
For all the text document messages, see reference \cite{LSPSpec}.
\subsubsection{Workspace service}
All the workspace messages, are handled by this service. More details regarding this type of messages can be studied at reference \cite{LSPSpec}.
\subsubsection{Utils service}
\textit{Utils} service provide functionalities such as syntax checking and document synchronization. For each time a document synchronization message, e.g. \verb|textDocument/didChange|, is received by \textit{textDocument} service, the latter forwards it to \textit{Utils} service that keeps a data structure with all the documents that are open in a specific moment. Subsequently, a syntax check is executed on the updated or newly opened document, and the result is sent to the main service which in turn forwards it to the client.
\chapter{Implementation}
For implementing the Language Server for Jolie, modeled in the previous chapter, I used the language Jolie itself for the following reasons:
\begin{itemize}
	\item \textbf{Service orientation}: Jolie, as described in Chapter 2, is microservice-oriented language, which is perfect for the non-functional requirements described in \hyperref[sec:Analysis]{Chapter 3}, in particular NFR 1, as Jolie already supports the JSON-RPC protocol over HTTP, therefore it must be adapted to the protocol used by LSP, by extending its functionalities. Moreover, Jolie has an service included in the standard library, called \textit{Inspector}, that provides code inspection operations for analyzing Jolie source code, therefore useful in order to meet \hyperref[cap:FR]{FR 1} and \hyperref[cap:FR]{FR 2}.
	\item The macroservice concept is realized with the \textit{static embedding} primitive: the main service embeds all the other three service, therefore all four services will run in the same virtual machine. This will reflect in faster internal communications. Furthermore, the main service \textit{aggregates} the output ports pointed respectively to the services \textit{workspace} and \textit{textDocument} to guarantee an automatic forward of the messages that are not of its concern.
\end{itemize}
\label{sec:impl}
\section{Choosing a language: Jolie (why)}

\section{Implementation details}
\subsection{Complying with LSP's JSON-RPC protocol}
% TODO rivedere testo, far capire che c'è stato un problema di compatibilità tra i protocolli
% e come si è risolto
The JSON-RPC 2.0 is a remote procedure call protocol that uses the JSON, a lightweight data-interchange format which is language independent. As stated in \hyperref[sec:JolieLSP]{Chapter 2}, an LSP message supports only two headers (\textit{Content-Lenghth} and \textit{Content-Type}), while the Jolie protocol runs over HTTP. This incompatibility led to a complex rework on the aforementioned Jolie protocol in order to meet the FR 1.\\ Further details can be read in \hyperref[sec:impl]{Chapter 5}.
\chapter{Validation}
\section{Met requirements (screenshots)}
\section{Unmet requirements}

\chapter{Conclusions: review, what needs to be done}

%% Fine dei capitoli normali, inizio dei capitoli-appendice (opzionali)
\appendix

\part{Appendici}

\chapter{Altro capitolo}

%% Parte conclusiva del documento; tipicamente per riassunto, bibliografia e/o indice analitico.
\backmatter

%% Riassunto (opzionale)
\summary

%% Bibliografia (opzionale)
\bibliographystyle{plain_\languagename}%% Carica l'omonimo file .bst, dove \languagename è la lingua attiva.
%% Nel caso in cui si usi un file .bib (consigliato)
\bibliography{thud}
%% Nel caso di bibliografia manuale, usare l'environment thebibliography.

%% Per l'indice analitico, usare il pacchetto makeidx (o analogo).

\end{document}

--- Istruzioni per l'aggiunta di nuove lingue ---
Per ogni nuova lingua utilizzata aggiungere nel preambolo il seguente spezzone:
    \addto\captionsitalian{%
        \def\abstractname{Sommario}%
        \def\acknowledgementsname{Ringraziamenti}%
        \def\authorcontactsname{Contatti dell'autore}%
        \def\candidatename{Candidato}%
        \def\chairname{Direttore}%
        \def\conclusionsname{Conclusioni}%
        \def\cosupervisorname{Co-relatore}%
        \def\cosupervisorsname{Co-relatori}%
        \def\cyclename{Ciclo}%
        \def\datename{Anno accademico}%
        \def\indexname{Indice analitico}%
        \def\institutecontactsname{Contatti dell'Istituto}%
        \def\introductionname{Introduzione}%
        \def\prefacename{Prefazione}%
        \def\reviewername{Controrelatore}%
        \def\reviewersname{Controrelatori}%
        %% Anno accademico
        \def\shortdatename{A.A.}%
        \def\summaryname{Riassunto}%
        \def\supervisorname{Relatore}%
        \def\supervisorsname{Relatori}%
        \def\thesisname{Tesi di \expandafter\ifcase\csname thud@target\endcsname Laurea\or Laurea Magistrale\or Dottorato\fi}%
        \def\tutorname{Tutor aziendale%
        \def\tutorsname{Tutor aziendali}%
    }
sostituendo a "italian" (nella 1a riga) il nome della lingua e traducendo le varie voci.
